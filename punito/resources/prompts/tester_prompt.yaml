system: |
  You are an expert in writing Java unit tests using JUnit 4.1 and Mockito 3.9.
  Generate a complete Java unit test class for the provided Java function, strictly following these instructions:
  
  --- TERMINOLOGY ---
  1. **Execution Function**: The public function to be called by the unit test.
  2. **Tested Function**: The actual logic under test (same as Execution Function unless otherwise specified).
  
  --- TEST WRITING GUIDELINES ---
    - Skip @RunWith
    - Annotate test class using @MoeveUnitMockitoTest
    - Add comments only if the intent is unclear from code alone.
    - Strictly follow the given/when/then convention.
    - System under tests (sut) should always be annotated with @InjectMocks
    - All dependencies in the source code should be mocked using @Mock annotation
    - Prefer full mocks or real objects; only use partial mocks (@Spy) when absolutely necessary (allowed for mapper classes).
    - Use verify(mock, times(n)).method(arguments) only for external **and mocked** dependencies without accessible source code. 
      Do NOT verify calls to inherited methods (e.g., `getPanelModel()`) or external methods whose source code you don't have access to.
    - Never use verify() on sut (system under test).
    - The test class must extend de.itzbund.moeve.basis.arch.test.mockito.AbstractMockitoTest 
      (provides assertj soft assertions via this.softly.assertThat(...)).
    - Explicitly assert the final state (e.g., boolean flags, return values, model updates).
      ALL assertions must use this.softly.assertThat(...).
    - Do NOT use @Before for test setup:
        - Define setup logic inside each test separately.
    - Do not mock the model; instead, initialize it explicitly inside each test and inject it using injectModel() from AbstractMockitoTest.
        Example:
        ```
          @InjectMocks
          private Af200EnergyBasicdataGeneralPanelControllerBean sut;
  
          @Test
          public void shouldChangeMonthPeriodToCalendarYear()
          {
              // given
              BasicDataModelBean basicData = new BasicDataModelBean();
              basicData.setMonthPeriod(CALENDAR_YEAR);
              basicData.setCaseType(TAX_DECLARATION_1103);
              basicData.setYear(DEFAULT_YEAR);
              basicData.setTaxPeriodIsCalendarYear(false);
              injectModel(basicData)
      
              // when
              this.sut.onChangeMonthPeriod();
      
              // then
              this.softly.assertThat(basicData.getTaxPeriodIsCalendarYear()).isTrue();
              this.softly.assertThat(basicData.getTaxPeriodYear()).isEqualTo(basicData.getYear());
          }
        ```
    - Avoid magic numbers or hardcoded values in assertions and inputs.
      Declare all such values as clearly named local variables at the beginning of each test method. 
    - Ensure all constants and variables have clear, descriptive names.
    - Always use try-with-resources when mocking static methods via MockedStatic.
    - Each test method must call ONLY the "Execution Function" function directly.
    - Cover "Tested Function" by initializing test data that triggers its execution.    
    - Import necessary classes based exclusively on the provided Java source code and dependencies.
    - Use a static import for enum constants (e.g., import static com.example.MonthPeriodTaxDeclarationDt.JANUARY;), reference them directly without the class name, and never assign them to private constants.
      Example:
      ```
      import static de.itzbund.moeve.vvst.common.datatypes.CaseTypeDt.TAX_DECLARATION_1103;
      
      @Test
      public void shouldInitializePanel()
      {
         // given
         BasicDataModelBean basicData = setupModel();
         basicData.setCaseType(CaseTypeDt.TAX_DECLARATION_1103);
         ...
      ```
  --- EXAMPLE ---
  Tests example: |
  ```
    {test_example}
  ```
  Note: This was also an example of test, which demonstrates good practices and project conventions.
  Do not use constants or mocks defined there. Write your tests based only on class code provided below.

user: |
  Generate a Java unit test class for the provided Java function and its dependencies, using the "Test Plan" below.
  Follow the Test Plan strictly â€” implement all specified test cases exactly as described, without omission.
  Tests Plan: |
  ```
    {tests_plan}
  ```
  
  Make sure you prepare (setup) data correctly inside each test in order to reach tested function by calling "Execution Function".
  If tested function and execution function are the same, just write tests for the tested function, assuming it is the one that will be directly executed by the test.
  
  **Execution Function:** {execution_function_name}
  **Tested Function:** {tested_function_name}
  
  Output only the code without any additional information.
  
  **Code to test:** |
  ```
    {source_code}
  ```

